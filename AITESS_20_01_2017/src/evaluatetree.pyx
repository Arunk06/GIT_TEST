# -*- coding: utf-8 -*-
#
# Package name		    : AITESS
# Module name		    : evaluatetree
# File name		        : evaluatetree.pyx
# Usage			        : Tree evaluator for the parse tree generated by AITESS.
# Authors		        : Hari Kiran K (Sc)
# Date of creation	    : N/A
#
# Modification history  :
#
# Mod1: hari on 23/03/2015
#       For displaying read values in hex when RHS of read with a 
#       comparison to integer is used. 
#       Eg: symbol = 15 ? should show
#           symbol(1111) + 0 = 0x15?
#           <      74247> (       0x15,        0x15,        0x15,        0x15)
#       instead of
#           symbol(1111) + 0 = 0x15?
#           <      74247> (         21,          21,          21,          21)
# Mod2: hari on 27/03/2015
#       RDF file versioning to be made optional because AIRDATS-E
#       does not want it (requested by SED, Chandrashekhar)
#       * shifted to syntaxtree.pyx as Mod2
# Mod3: hari on 01/04/2015
#       init_1553(filename) will now support '~' and '.' in filename
# Mod4: hari on 22/06/2015
#       Versioned RDF should have the format filename.rdf;00 instead of 
#       filename{00000}.rdf.
#       Refer: IV & V Report No. ADA/LCA/IVV/FCS/57/2015 dated 09/06/2015
#       * shifted to syntaxtree.pyx as Mod3
# Mod5: hari on 22/06/2015
#       Execution completed message should be displayed after executing a TPF.
#       Refer: IV & V Report No. ADA/LCA/IVV/FCS/57/2015 dated 09/06/2015
# Mod6: hari on 22/06/2015
#       RDF header should include RDF path.
#       Refer: IV & V Report No. ADA/LCA/IVV/FCS/57/2015 dated 09/06/2015
# Mod7: hari on 29/06/2015
#       TIP addresses will be restricted to 32bits.
# Mod8: hari on 02/07/2015
#       User functions need not be expanded in RDF by default. To make a 
#       function expandable put a "*" character immediately after the
#       function name in the function declaration. 
#       (requested by SED, Chandrashekhar)
# Mod9: hari on 28/09/2015
#       TIP # DMAR and TIP # DMAS functions are different in ADC, LADC and DFCC.
# Mod10: hari on 19/10/2015    
#       Patch files will be now under the ownership of the current user not under
#       root
# Mod11: hari on 04/02/2016
#        Correction of DMAS and DMAR sequences for LADC (DMAR while WDM up was 
#        causing WDM to go down).
#        

import sys
from cpython cimport bool
import datetime
import subprocess
from math import sin, cos, tan
from errorhandler import EvaluationError, ExitError, UserExitError, AssertError
import syntaxtree as tree
import cfg  # globals
from tokens import TokenType
from time import time, sleep
from re import match
from message import ErrorMessage, NormalMessage, CommentMessage, ListingMessage, SymbolMessage, TipSingleMessage, \
    TipMultipleMessage, TipMultipleFloatMessage, TipSingleWriteMessage, TipMultipleWriteMessage, \
    TipStatusMessage, DownloadMessage, UploadMessage, VerifyMessage, ProgramMessage, TipBitMarchMessage
from nametype import StringVariable, NumericVariable, Function, Macro
import tempfile, os
from datatable import SymbolTable
from inspect import getmembers, isclass
from cython.operator cimport dereference as deref
import output

include "settings.pyi"

cdef inline float u32toffp(unsigned long value):
    return deref(<float *> &value)

cdef inline ffptou32(float value):
    return deref(<unsigned long *> &value)


class BreakLoop(Exception):
    pass


class ContinueLoop(Exception):
    pass


class ReturnValue(Exception):
    def __init__(self, v, t):
        super(ReturnValue, self).__init__(v, t)


# Visitor base class.

cdef class TreeVisitor(object):
    cpdef dict lookup_table
    cpdef object visitor_method

    def __init__(self):
        super(TreeVisitor, self).__init__()
        self.visitor_method = getattr(self, 'visit')
        self.lookup_table = {}
        self.lookup_table.clear()
        self.__prefetch_lookup_table()

    cpdef __prefetch_lookup_table(self):
        for node_name, node_class in getmembers(tree, isclass):
            method_name = 'visit' + node_name
            visitor = getattr(self, method_name, self.generic_visit)
            self.lookup_table[node_class] = visitor

    cpdef visit(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            return self.lookup_table[node.__class__](node, args, kargs)
        except KeyboardInterrupt:
            raise EvaluationError("Evaluation terminated through Ctrl-C", node.source_info)

    # The generic visior,
    cpdef generic_visit(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        raise EvaluationError(
            "TreeVisitor: '%s' not yet implemented." % (self.__class__.__name__ + node.__class__.__name__),
            node.source_info)

cdef list diffs = ['', '', '', '']
cdef list system_channel_values = []

# Dynamic configuration for ADC/LADC 21/11/2013
cdef unsigned long wdm_address

cdef bool verify_completed = False

cdef class TreeEvaluator(TreeVisitor):
    file_name = ''
    function_stack = []
    cpdef public bool spil_prefetch_flag
    cpdef public list spil_prefetch_list
    cpdef public list rs422_node_list

    def __init__(self):
        super(TreeEvaluator, self).__init__()
        global wdm_address
        self.spil_prefetch_flag = False
        self.spil_prefetch_list = []
        self.rs422_node_list = []
        if cfg.config_file.is_configured_for_ADC():
            wdm_address = 0x400000
        elif cfg.config_file.is_configured_for_LADC() or cfg.config_file.is_configured_for_DFCC():
            wdm_address = 0x3D6028
        elif cfg.config_file.is_configured_for_DFCC_MK1A() or cfg.config_file.is_configured_for_DFCC_MK2():
            wdm_address = 0x206d6028
        else:  # defaults to LADC/DFCC Mk1
            wdm_address = 0x3D6028

    cpdef address_validator(self, node, start_address, end_address, range_check=False):
        # Mod7: begin
        if (start_address < 0) or (start_address > 0xFFFFFFFF):
            raise EvaluationError("Address evaluated to an invalid value of %s" % hex(start_address),
                                  node.source_info)
        # Mod7: end

        # Mod7: begin
        if (end_address < 0) or (end_address > 0xFFFFFFFF):
            raise EvaluationError("Address evaluated to an invalid value of %s" % hex(end_address),
                                  node.source_info)
        # Mod7: end

        if start_address > end_address:
            raise EvaluationError(
                "Start address evaluated to a value greater than end address, 0x%x > 0x%x" % (
                    start_address, end_address), node.source_info)

        # (DPRAM_END_ADDRESS - NON_CONT_ALLOCATION_START_ADDRESS) / NUMBER_OF_LOCATIONS_FOR_EACH_TRANSACTION + 1 
        # = (0x7FFF - 0x4100) / 4 + 1
        # = 4032
        non_contigous_transaction_limit = 4032
        if range_check and ((end_address - start_address) > non_contigous_transaction_limit):
            raise EvaluationError("Address range generated exceeds the maximum supported, %s > %s" % (
                (end_address - start_address), non_contigous_transaction_limit),
                                  node.source_info)

    cpdef visitDelayedParseError(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.output_queue.append(ErrorMessage(node.to_text(), node.message, display=True, generate_rdf=cfg.generate_rdf))

    # Visitors for the arithmetic group.
    cpdef visitAdd(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return self.visit(node.left) + self.visit(node.right)

    cpdef visitSubtract(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return self.visit(node.left) - self.visit(node.right)

    cpdef visitMultiply(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return self.visit(node.left) * self.visit(node.right)

    cpdef visitDivide(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = 0
        numerator = self.visit(node.left)
        denominator = self.visit(node.right)

        try:
            value = numerator / denominator
        except ZeroDivisionError:
            raise EvaluationError("Division by zero", node.source_info)

        return value

    cpdef visitModulo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = 0
        numerator = self.visit(node.left)
        denominator = self.visit(node.right)

        try:
            value = numerator % denominator
        except ZeroDivisionError:
            raise EvaluationError("Modulo by zero", node.source_info)

        return value

    cpdef visitMinus(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return -1 * self.visit(node.left)

    cpdef visitPlus(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return +1 * self.visit(node.left)  # ;-)

    # Visitors for the logical group.

    cpdef visitNot(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = int(not self.visit(node.left))
        return value

    cpdef visitOr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = int(self.visit(node.left) or self.visit(node.right))
        return value

    cpdef visitAnd(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = int(self.visit(node.left) and self.visit(node.right))
        return value

    cpdef visitBitNot(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = int(~ self.visit(node.left))
        return value

    cpdef visitBitOr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) | self.visit(node.right)
        return value

    cpdef visitBitXOr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) ^ self.visit(node.right)
        return value

    cpdef visitBitAnd(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) & self.visit(node.right)
        return value

    cpdef visitLeftShift(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) << self.visit(node.right)
        return value

    cpdef visitRightShift(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) >> self.visit(node.right)
        return value

    cpdef visitIn(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        (range_begin, range_end) = self.visit(node.range_expr)
        result = self.visit(node.expr, (), {'bypass': False})
        result['compare'] = [('unused' if v == 'unused' else (range_begin <= v <= range_end)) for v in result['value']]

        return result

    cpdef visitBypassIn(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        (range_begin, range_end) = self.visit(node.range_expr)
        result = self.visit(node.expr, (), {'bypass': True})
        result['compare'] = [('unused' if v == 'unused' else (range_begin <= v <= range_end)) for v in result['value']]

        return result

    cpdef visitNotIn(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        (range_begin, range_end) = self.visit(node.range_expr)
        result = self.visit(node.expr, (), {'bypass': False})
        result['compare'] = [('unused' if v == 'unused' else not (range_begin <= v <= range_end)) for v in
                             result['value']]

        return result

    cpdef visitBypassNotIn(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        (range_begin, range_end) = self.visit(node.range_expr)
        result = self.visit(node.expr, (), {'bypass': True})
        result['compare'] = [('unused' if v == 'unused' else not (range_begin <= v <= range_end)) for v in
                             result['value']]

        return result

    # Visitors for the equality group.

    cpdef visitEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) == self.visit(node.right)
        return value

    cpdef visitNotEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) != self.visit(node.right)
        return value

    cpdef visitChannelEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': False})
        result['compare'] = [('unused' if v == 'unused' else v == right) for v in result['value']]

        # Mod1: begin
        if cfg.legacy_syntax:  # Old syntax
            if isinstance(node.right, tree.Hexadecimal):
                result['bypass'] = True  # Psuedo bypass for displaying read values in hex
        # Mod1: end

        return result

    cpdef visitChannelBypassEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': True})
        result['compare'] = [('unused' if v == 'unused' else v == right) for v in result['value']]
        return result

    cpdef visitChannelNotEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': False})
        result['compare'] = [('unused' if v == 'unused' else v != right) for v in result['value']]
        return result

    cpdef visitChannelBypassNotEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': True})
        result['compare'] = [('unused' if v == 'unused' else v != right) for v in result['value']]
        return result

    # Visitors for the relational group.

    cpdef visitLessThan(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) < self.visit(node.right)
        return value

    cpdef visitLessThanEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) <= self.visit(node.right)
        return value

    cpdef visitGreaterThan(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) > self.visit(node.right)
        return value

    cpdef visitGreaterThanEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.left) >= self.visit(node.right)
        return value

    cpdef visitChannelLessThan(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': False})
        result['compare'] = [('unused' if v == 'unused' else v < right) for v in result['value']]
        return result

    cpdef visitChannelBypassLessThan(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': True})
        result['compare'] = [('unused' if v == 'unused' else v < right) for v in result['value']]
        return result

    cpdef visitChannelLessThanEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': False})
        result['compare'] = [('unused' if v == 'unused' else v <= right) for v in result['value']]
        return result

    cpdef visitChannelBypassLessThanEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': True})
        result['compare'] = [('unused' if v == 'unused' else v <= right) for v in result['value']]
        return result

    cpdef visitChannelGreaterThan(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': False})
        result['compare'] = [('unused' if v == 'unused' else v > right) for v in result['value']]
        return result

    cpdef visitChannelBypassGreaterThan(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': True})
        result['compare'] = [('unused' if v == 'unused' else v > right) for v in result['value']]
        return result

    cpdef visitChannelGreaterThanEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': False})
        result['compare'] = [('unused' if v == 'unused' else v >= right) for v in result['value']]
        return result

    cpdef visitChannelBypassGreaterThanEqualTo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        right = self.visit(node.right)
        result = self.visit(node.left, (), {'bypass': True})
        result['compare'] = [('unused' if v == 'unused' else v >= right) for v in result['value']]
        return result

    # Visitor for assignment operator.

    cpdef visitAssign(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.r_value)
        if isinstance(node.l_value, tree.Identifier) or \
                isinstance(node.l_value, tree.LocalIdentifier):
            self.visit(node.l_value, (), {'value': value})
        else:
            raise EvaluationError("L-value required in expression (cannot assign to literal, parameter or function)",
                                  node.source_info)

        return value

    cpdef visitChannelAssign(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.r_value)
        if isinstance(node.l_value, tree.SymbolAccess):
            value = self.visit(node.l_value, (), {'bypass': False, 'value': value})
            value['compare'] = [('unused' if v == 'unused' else True) for v in value['value']]
        else:
            raise EvaluationError("L-value required in expression",
                                  node.source_info)

        return value

    cpdef visitChannelBypassAssign(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.r_value)
        if isinstance(node.l_value, tree.SymbolAccess):
            value = self.visit(node.l_value, (), {'bypass': True, 'value': value})
            value['compare'] = [('unused' if v == 'unused' else True) for v in value['value']]
        else:
            raise EvaluationError("L-value required in expression",
                                  node.source_info)

        return value

    # Visitors for expression elements group.

    cpdef visitRange(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return self.visit(node.lower), self.visit(node.upper)

    cpdef visitTolerance(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        base = self.visit(node.base)
        shift = abs(base * self.visit(node.tolerance) / 100)  #100.0
        node.begin = (base - shift)
        node.end = (base + shift)
        return (base - shift), (base + shift)

    cpdef visitIdentifier(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if kargs.has_key('value'):
            value = kargs['value']
            if type(value) is str:
                cfg.symbol_table.put_entry(node.name, StringVariable(node.name, value, node.source_info))
            else:
                cfg.symbol_table.put_entry(node.name, NumericVariable(node.name, value, node.source_info))
        else:
            try:
                dynamic_object = cfg.symbol_table.get_entry(node.name)
            except KeyError:
                message = "Unknown name '%s', implicitly used as a variable" % node.name
                raise EvaluationError(message, node.source_info)

            if isinstance(dynamic_object, StringVariable) or isinstance(dynamic_object, NumericVariable):
                value = dynamic_object.read()
            else:
                message = "Previously implicit variable '%s' defined as type '%s'" % \
                          (node.name, dynamic_object.__class__.__name__.lower())
                raise EvaluationError(message, node.source_info)

        return value

    cpdef visitSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}

    # symbol reading
    # convert read 4 byte unsigned hex to required symbol type and compare with rhs or display
    # symbol writing
    # convert rhs to 4 byte unsigned hex and write it to the symbol
    cdef inline __SPIL_prefetch_write(self, node, bypass, value):
        if self.spil_prefetch_flag:
            self.spil_prefetch_list.append(
                {'write': True, 'symbol': node.symtab_entry, 'user_mask': self.visit(node.user_mask),
                 'user_offset': self.visit(node.user_offset), 'bypass': bypass, 'data': value})
            return {'bypass': bypass, 'frame': 0, 'value': (0, 0, 0, 0), 'status': (0x0, 0x0, 0x0, 0x0)}
        else:
            return cfg.shm.write_spil()

    cdef inline __SPIL_prefetch_read(self, node, bypass):
        if self.spil_prefetch_flag:
            self.spil_prefetch_list.append(
                {'write': False, 'symbol': node.symtab_entry, 'user_mask': self.visit(node.user_mask),
                 'user_offset': self.visit(node.user_offset), 'bypass': bypass})
            return {'bypass': bypass, 'frame': 0, 'value': (0, 0, 0, 0), 'status': (0x0, 0x0, 0x0, 0x0)}
        else:
            return cfg.shm.read_spil()

    cpdef visitSPILSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())
        if kargs.has_key('value'):  # writing
            return self.__SPIL_prefetch_write(node, kargs['bypass'], kargs['value'])
        else:
            return self.__SPIL_prefetch_read(node, kargs['bypass'])

    cpdef visitCCDLInSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_ccdlin(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                        kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_ccdlin(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                       kargs['bypass'])

    cpdef visitCCDLOutSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_ccdlout(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                         kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_ccdlout(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                        kargs['bypass'])

    cpdef visitCCDLTaskSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_ccdltask(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                          kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_ccdltask(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                         kargs['bypass'])

    cpdef visitDPFSSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_dpfs(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                      kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_dpfs(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                     kargs['bypass'])

    cpdef visitSIMPROCInSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        try:
            if kargs.has_key('value'):  # writing
                return cfg.shm.write_simproc(node.symtab_entry, self.visit(node.user_mask),
                                             self.visit(node.user_offset), kargs['bypass'], kargs['value'])
            else:
                return cfg.shm.read_simproc(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                            kargs['bypass'])
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitSIMPROCOutSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        try:
            if kargs.has_key('value'):  # writing
                return cfg.shm.write_simproc(node.symtab_entry, self.visit(node.user_mask),
                                             self.visit(node.user_offset), kargs['bypass'], kargs['value'])
            else:
                return cfg.shm.read_simproc(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                            kargs['bypass'])
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitSIMPROCTaskSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_simproc()
        else:
            return cfg.shm.read_simproc()

    cpdef visitRS422InSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_rs422in(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                         kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_rs422in(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                        kargs['bypass'])

    cpdef visitRS422OutSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            self.rs422_node_list.append(node.symtab_entry)
            return cfg.shm.write_rs422out(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                          kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_rs422out(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                         kargs['bypass'])

    cpdef visitRS422TaskSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_rs422task(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                           kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_rs422task(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                          kargs['bypass'])

    cpdef visitRS422ErrorSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_rs422error(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                            kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_rs422error(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                           kargs['bypass'])

    cpdef visitMIL1553BInSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_mil1553bin(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                            kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_mil1553bin(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                           kargs['bypass'])

    cpdef visitMIL1553BOutSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_mil1553bout(node.symtab_entry, self.visit(node.user_mask),
                                             self.visit(node.user_offset), kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_mil1553bout(node.symtab_entry, self.visit(node.user_mask), self.visit(node.user_offset),
                                            kargs['bypass'])

    cpdef visitMIL1553BTaskSymbolAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, self.visit(node.user_mask), node.symtab_entry.get_chan())

        if kargs.has_key('value'):  # writing
            return cfg.shm.write_mil1553btask(node.symtab_entry, self.visit(node.user_mask),
                                              self.visit(node.user_offset), kargs['bypass'], kargs['value'])
        else:
            return cfg.shm.read_mil1553btask(node.symtab_entry, self.visit(node.user_mask),
                                             self.visit(node.user_offset), kargs['bypass'])

    cpdef visitString(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return node.value

    cpdef visitInteger(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return node.value

    cpdef visitHexadecimal(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return node.value

    cpdef visitOctal(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return node.value

    cpdef visitBinary(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return node.value

    cpdef visitFloat(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        return node.value

    # Visitors for program elements group.

    cpdef visitEmpty(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        raise EvaluationError("Empty node was visited, this should never have happened", node.source_info)

    cpdef visitFrWait(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        count = self.visit(node.count)
        for i in xrange(count):
            cfg.shm.wait_for_transition()
        output_str = 'Waited %s frame(s).' % count
        cfg.output_queue.append(
            NormalMessage(node.to_text(), output_str, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitWait(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        delay = self.visit(node.delay)
        sleep(delay)
        output_str = 'Waited %s second(s).' % delay
        cfg.output_queue.append(
            NormalMessage(node.to_text(), output_str, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipEprNDsb(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        result = cfg.shm.reg_poke_nc((0x15554, 0xAAAAAAAA, 4, 0,
                                      0xAAA8, 0x55555555, 4, 0,
                                      0x15554, 0x80808080, 4, 0,
                                      0x15554, 0xAAAAAAAA, 4, 0,
                                      0xAAA8, 0x55555555, 4, 0,
                                      0x15554, 0x20202020, 4, 0))
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipEprNEnb(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        result = cfg.shm.reg_poke_nc((0x15554, 0xAAAAAAAA, 4, 0,
                                      0xAAA8, 0x55555555, 4, 0,
                                      0x15554, 0xA0A0A0A0, 4, 0))
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipEprTDsb(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        result = cfg.shm.reg_poke_nc((0x95554, 0xAAAAAAAA, 4, 0,
                                      0x8AAA8, 0x55555555, 4, 0,
                                      0x95554, 0x80808080, 4, 0,
                                      0x95554, 0xAAAAAAAA, 4, 0,
                                      0x8AAA8, 0x55555555, 4, 0,
                                      0x95554, 0x20202020, 4, 0))
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipEprTEnb(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        result = cfg.shm.reg_poke_nc((0x95554, 0xAAAAAAAA, 4, 0,
                                      0x8AAA8, 0x55555555, 4, 0,
                                      0x95554, 0xA0A0A0A0, 4, 0))
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipEprNErs(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        result = cfg.shm.reg_poke_nc((0x15554, 0xAAAAAAAA, 4, 0,
                                      0xAAA8, 0x55555555, 4, 0,
                                      0x15554, 0x80808080, 4, 0,
                                      0x15554, 0xAAAAAAAA, 4, 0,
                                      0xAAA8, 0x55555555, 4, 0,
                                      0x15554, 0x10101010, 4, 0))
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipEprTErs(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        result = cfg.shm.reg_poke_nc((0x95554, 0xAAAAAAAA, 4, 0,
                                      0x8AAA8, 0x55555555, 4, 0,
                                      0x95554, 0x80808080, 4, 0,
                                      0x95554, 0xAAAAAAAA, 4, 0,
                                      0x8AAA8, 0x55555555, 4, 0,
                                      0x95554, 0x10101010, 4, 0))
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipDf(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        start_address = self.visit(node.fifo_address)
        count = self.visit(node.count)
        end_address = start_address + count * 0x4

        self.address_validator(node, start_address, end_address)

        result = ()
        for address in range(start_address, end_address, 0x4):
            result += cfg.shm.peek_c(start_address, start_address, 4)
        system_channel_values = [(r['value']) for r in result]

        cfg.output_queue.append(
            TipMultipleMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipFfc(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        start_address = self.visit(node.fifo_address)
        data = self.visit(node.data)
        count = self.visit(node.count)
        end_address = start_address + count * 0x4

        # addr, data, type, mask
        parameter = ()

        for address in range(start_address, end_address, 0x4):
            parameter += (start_address, data, 4, 0)

        transaction_count = len(parameter) / 4
        self.address_validator(node, start_address, start_address + transaction_count, range_check=True)

        result = cfg.shm.reg_poke_nc(parameter)

        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipFfi(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        start_address = self.visit(node.fifo_address)
        data = self.visit(node.initial_data)
        count = self.visit(node.count)
        end_address = start_address + count * 0x4

        # addr, data, type, mask
        parameter = ()

        for address in range(start_address, end_address, 0x4):
            parameter += (start_address, data, 4, 0)
            data += 1

        transaction_count = len(parameter) / 4
        self.address_validator(node, start_address, start_address + transaction_count, range_check=True)

        result = cfg.shm.reg_poke_nc(parameter)

        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipMtd(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        start_address = self.visit(node.start_address)
        end_address = self.visit(node.end_address)
        bit = self.visit(node.bit)

        self.address_validator(node, start_address, end_address)

        result = cfg.shm.bit_march_test(start_address, end_address, 0x4, bit)
        cfg.output_queue.append(
            TipBitMarchMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipMtw(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        start_address = self.visit(node.start_address)
        end_address = self.visit(node.end_address)
        bit = self.visit(node.bit)

        self.address_validator(node, start_address, end_address)

        result = cfg.shm.bit_march_test(start_address, end_address, 0x2, bit)
        cfg.output_queue.append(
            TipBitMarchMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipMtb(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        start_address = self.visit(node.start_address)
        end_address = self.visit(node.end_address)
        bit = self.visit(node.bit)

        self.address_validator(node, start_address, end_address)

        result = cfg.shm.bit_march_test(start_address, end_address, 0x1, bit)
        cfg.output_queue.append(
            TipBitMarchMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cdef inline compare_tip_value(self, start_address, end_address, result, value):
        cdef list mismatch_count = [0, 0, 0, 0]
        cdef list channel_differences = ["unused", "unused", "unused", "unused"]
        cdef list status = [0x0, 0x0, 0x0, 0x0]
        cdef unsigned char channel
        cdef dict differences = {}
        cdef bool is_unused = False

        for channel from 0 <= channel < 4:
            is_unused = False
            differences = {}
            for r in result:
                if not r['status'][channel] and (r['value'][channel] != 'unused'):
                    read_value = r['value'][channel]
                    if read_value != value:
                        differences[r['address']] = (read_value, value)

                if r['status'][channel]:  # error
                    status[channel] = r['status'][channel]
                if r['value'][channel] == 'unused':
                    is_unused = True

            if is_unused:
                channel_differences[channel] = "unused"
            else:
                channel_differences[channel] = {'differences': differences}
                channel_differences[channel]['status'] = status[channel]

        return {'start_address': start_address, 'end_address': end_address, 'channels': tuple(channel_differences)}

    cpdef visitTipVr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        start_address = self.visit(node.start_address)  # & 0xfffffffc
        end_address = self.visit(node.end_address)  # & 0xfffffffc
        data = self.visit(node.data)

        self.address_validator(node, start_address, end_address)

        result = self.block_peek_c(start_address, end_address, 4)
        system_channel_values = [(r['value']) for r in result]
        result = self.compare_tip_value(start_address, end_address, result, data)  # Add comparison information

        for channnel in xrange(4):
            try:
                diffs[channnel] = result['channels'][channnel]['differences']
            except TypeError:
                diffs[channnel] = result['channels'][channnel]

        cfg.output_queue.append(
            VerifyMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipP(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        # action code for transputer based DFCC should be put here

        cfg.output_queue.append(NormalMessage(node.to_text(), "Not yet implemented", display=cfg.display_state,
                                              generate_rdf=cfg.generate_rdf))

    cpdef visitTipPl(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        # action code
        # peek 0x200200(SRAM) and check status code if no error declare SPIL healthy
        result = cfg.shm.peek_c(0x200200, 0x200200, 4)

        # aesthetics ;-)
        result[0]['address'] = cfg.shm.boot_message_addr
        cfg.output_queue.append(
            TipStatusMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipBo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        result = cfg.shm.boot()
        cfg.output_queue.append(
            TipSingleMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipWdm(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values, wdm_address
        cfg.shm.wait_for_transition()

        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        result = cfg.shm.peek_nc((wdm_address, 4, 0))
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipDmas(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        # Mod9: begin
        if cfg.config_file.is_configured_for_DFCC():
            result = cfg.shm.reg_poke_nc((0x500000, 0x55555555, 4, 0,
                                          0x500020, 0xaaaaaaaa, 4, 0))
        elif cfg.config_file.is_configured_for_DFCC_MK2():
            raise EvaluationError("No DMAS sequence available for DFCC Mk2", node.source_info)
        elif cfg.config_file.is_configured_for_LADC():
            # Mod11: begin
            result = cfg.shm.reg_poke_nc((0x500000, 0x55555555, 4, 0,
                                          0x320000, 0x00000000, 4, 0))
            # Mod11: end
        elif cfg.config_file.is_configured_for_ADC():
            result = cfg.shm.reg_poke_nc((0x500000, 0x55555555, 4, 0))
        else:
            raise EvaluationError("No DMAS sequence for this UUT", node.source_info)
        # Mod9: end

        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipDmar(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        # Mod9: begin
        if cfg.config_file.is_configured_for_DFCC():
            result = cfg.shm.reg_poke_nc((0x500000, 0x55555555, 4, 0))
        elif cfg.config_file.is_configured_for_DFCC_MK2():
            raise EvaluationError("No DMAR sequence available for DFCC Mk2", node.source_info)
        elif cfg.config_file.is_configured_for_LADC():
            # Mod11: begin
            # Set bit 8 to 0, but is it a write only register? if so,
            # discrete setting using DIS_32 (code 0x44) wont work
            result = cfg.shm.reg_poke_nc((0x500020, 0xaaaaaaaa, 4, 0))
            # Mod11: end
        elif cfg.config_file.is_configured_for_ADC():
            # This sequence was taken from ITESS of AIRDATS
            result = cfg.shm.reg_poke_nc((0x400300, 0x00000000, 4, 0,
                                          0x500020, 0xaaaaaaaa, 4, 0))
        else:
            raise EvaluationError("No DMAR sequence for this UUT", node.source_info)
        # Mod9: end

        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipMrhp(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        address = self.visit(node.address)
        self.address_validator(node, address, address)
        result = cfg.shm.peek_c(address, address, 4)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipMrfp(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        address = self.visit(node.address)
        self.address_validator(node, address, address)
        result = cfg.shm.peek_c(address, address, 4)
        result[0]['value'] = tuple([u32toffp(r) if r != 'unused' else r for r in result[0]['value']])
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleFloatMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipMrhrp(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        address = self.visit(node.address)
        self.address_validator(node, address, address)
        result = cfg.shm.poke_c(address, address, self.visit(node.data), 4)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipSingleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipMrfrp(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        address = self.visit(node.address)
        self.address_validator(node, address, address)
        result = cfg.shm.poke_c(address, address, ffptou32(self.visit(node.data)), 4)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipSingleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cdef inline tuple block_peek_c(self, unsigned long start_address, unsigned long end_address,
                                   unsigned char data_type):
        cdef unsigned long max_transactions = 16384  # 16K DWORDS = 64KB
        cdef unsigned long transaction_count = (end_address - start_address) / data_type + 1
        cdef unsigned long block_count = transaction_count / max_transactions
        cdef unsigned int block
        cdef tuple result = ()

        for block from 0 <= block < block_count:
            result += cfg.shm.peek_c(start_address + max_transactions * data_type * block,
                                     start_address + max_transactions * data_type * block + (
                                         max_transactions - 1) * data_type, data_type)
            cfg.shm.wait_for_transition()  # Here because we wait for transition in the calling function

        if transaction_count % max_transactions:
            result += cfg.shm.peek_c(start_address + max_transactions * data_type * block_count, end_address, data_type)

        return result

    cpdef visitTipDd(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        start_address = self.visit(node.start_address)  # & 0xfffffffc
        end_address = self.visit(node.end_address)  # & 0xfffffffc
        self.address_validator(node, start_address, end_address)
        result = self.block_peek_c(start_address, end_address, 4)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipDw(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        effective_mask = cfg.global_mask
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        start_address = self.visit(node.start_address)  # & 0xfffffffe
        end_address = self.visit(node.end_address)  # & 0xfffffffe
        self.address_validator(node, start_address, end_address)
        result = self.block_peek_c(start_address, end_address, 2)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipDb(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        start_address = self.visit(node.start_address)
        end_address = self.visit(node.end_address)
        self.address_validator(node, start_address, end_address)
        result = self.block_peek_c(start_address, end_address, 1)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cdef inline tuple block_poke_c(self, unsigned long start_address, unsigned long end_address, unsigned long data,
                                   unsigned char data_type):
        cdef unsigned long max_transactions = 16384  # 16K DWORDS = 64KB
        cdef unsigned long transaction_count = (end_address - start_address) / data_type + 1
        cdef unsigned long block_count = transaction_count / max_transactions
        cdef unsigned int block
        cdef tuple result = ()

        for block from 0 <= block < block_count:
            result += cfg.shm.poke_c(start_address + max_transactions * data_type * block,
                                     start_address + max_transactions * data_type * block + (
                                         max_transactions - 1) * data_type, data, data_type)
            cfg.shm.wait_for_transition()  # Here because we wait for transition in the calling function

        if transaction_count % max_transactions:
            result += cfg.shm.poke_c(start_address + max_transactions * data_type * block_count, end_address, data,
                                     data_type)

        return result

    cpdef visitTipFd(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        start_address = self.visit(node.start_address)
        end_address = self.visit(node.end_address)
        data = self.visit(node.data)

        self.address_validator(node, start_address, end_address)
        result = self.block_poke_c(start_address, end_address, data, 4)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipSingleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipFw(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        start_address = self.visit(node.start_address)
        end_address = self.visit(node.end_address)
        data = self.visit(node.data)

        self.address_validator(node, start_address, end_address)
        result = self.block_poke_c(start_address, end_address, data, 2)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipSingleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipFb(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        start_address = self.visit(node.start_address)
        end_address = self.visit(node.end_address)
        data = self.visit(node.data)

        self.address_validator(node, start_address, end_address)
        result = self.block_poke_c(start_address, end_address, data, 1)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipSingleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipLd(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        parameter = ()
        address = self.visit(node.start_address)
        data_list = map(self.visitor_method, node.data_list)

        for data in data_list:
            parameter += (address, data, 4, 0)
            address += 0x4

        transaction_count = len(parameter) / 4
        self.address_validator(node, address, address + transaction_count, range_check=True)

        result = cfg.shm.poke_nc(parameter)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipLw(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        parameter = ()
        address = self.visit(node.start_address)
        data_list = map(self.visitor_method, node.data_list)

        for data in data_list:
            parameter += (address, data, 2, 0)
            address += 0x2

        transaction_count = len(parameter) / 4
        self.address_validator(node, address, address + transaction_count, range_check=True)

        result = cfg.shm.poke_nc(parameter)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipLb(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)

        parameter = ()
        address = self.visit(node.start_address)
        data_list = map(self.visitor_method, node.data_list)

        for data in data_list:
            parameter += (address, data, 1, 0)
            address += 0x1

        transaction_count = len(parameter) / 4
        self.address_validator(node, address, address + transaction_count, range_check=True)

        result = cfg.shm.poke_nc(parameter)
        system_channel_values = [(r['value']) for r in result]
        cfg.output_queue.append(
            TipMultipleWriteMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitTipCs(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()
        cfg.shm.set_symbolmask(cfg.global_mask, node.mask, 0b1111)
        start_address = self.visit(node.start_address)
        end_address = self.visit(node.end_address)
        self.address_validator(node, start_address, end_address)
        result = cfg.shm.find_checksum(start_address, end_address)
        cfg.output_queue.append(
            TipSingleMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitComment(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.output_queue.append(CommentMessage(node.to_text(), node.text, display=False, generate_rdf=cfg.generate_rdf))

    cpdef visitInputListing(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.output_queue.append(ListingMessage(node.to_text(), node.text, display=False, generate_rdf=cfg.generate_rdf))

    cpdef visitExpression(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            value = self.visit(node.child)
        except TypeError as e:
            raise EvaluationError("Incompatible operand types in expression (PYERR: %s)" % e,
                                  node.source_info)
        except KeyError as e:
            value = 0

        return value

    cpdef visitFinalValueExpression(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            value = self.visit(node.child)
        except TypeError as e:
            raise EvaluationError("Incompatible operand types in expression (PYERR: %s)" % e,
                                  node.source_info)
        except KeyError as e:
            value = 0

        node.final_value = value

        return value

    cpdef visitFinalValueExpressionHex(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            value = self.visit(node.child)
        except TypeError as e:
            raise EvaluationError("Incompatible operand types in expression (PYERR: %s)" % e,
                                  node.source_info)
        except KeyError as e:
            value = 0

        node.final_value = value

        return value

    cpdef visitFinalValueExpressionBin(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            value = self.visit(node.child)
        except TypeError as e:
            raise EvaluationError("Incompatible operand types in expression (PYERR: %s)" % e,
                                  node.source_info)
        except KeyError as e:
            value = 0

        node.final_value = value

        return value

    cpdef visitFinalValueExpressionString(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            value = self.visit(node.child)
        except TypeError as e:
            raise EvaluationError("Incompatible operand types in expression (PYERR: %s)" % e,
                                  node.source_info)
        except KeyError as e:
            value = ""

        node.final_value = value

        return value

    cpdef visitIf(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cdef list gated_statement
        cdef list gated_statement_list = node.gated_statement_list

        for gated_statement in gated_statement_list:
            if self.visit(gated_statement[0]):
                self.visit(gated_statement[1])
                break

    cpdef visitWhile(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cdef list stmt_list = node.stmt.get_statements()
        # resolve for extra speed
        expr = node.expr

        while self.visit(expr):
            try:
                for stmt in stmt_list:
                    self.visit(stmt)
            except ContinueLoop:
                continue
            except BreakLoop:
                break

    cpdef visitWfc(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        wait_value = self.visit(node.wait_value)
        curr_output_queue_size = len(cfg.output_queue)  # Save current output queue length

        while wait_value:
            if self.visit(node.sym_stmt):
                break
            wait_value -= 1

        cfg.output_queue = cfg.output_queue[:curr_output_queue_size]  # Remove new items in queue

        if wait_value:  # Value non-zero means condition has succedded
            cfg.output_queue.append(NormalMessage(node.to_text(), "Wait for condition succeeded.", display=True,
                                                  generate_rdf=cfg.generate_rdf))
        else:  # Condition failed
            cfg.output_queue.append(ErrorMessage(node.to_text(), "Wait for condition timed out.", display=True,
                                                 generate_rdf=cfg.generate_rdf))

    cpdef visitBreak(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        raise BreakLoop()

    cpdef visitContinue(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        raise ContinueLoop()

    cpdef bool __is_not_none(self, v):
        return v is not None

    cpdef visitLtmSytax(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.output_queue.append(
            NormalMessage(node.to_text(), node.message, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitPrint(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cdef list expr_list = node.expr_list
        cdef list value_list
        cdef str output_str = ''

        for expr in expr_list:
            value = self.visit(expr)
            if value is not None:
                output_str = "%s%s " % (output_str, str(value))

        cfg.output_queue.append(
            NormalMessage(node.to_text(), output_str, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

        output.print_output_queue()

    cpdef visitDownload(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_symbolmask(cfg.global_mask, node.user_mask, 0b1111)
        try:
            file_name = cfg.config_file.get_downloadpath(str(self.visit(node.file_name)))
            cfg.progress_bar.start_animation('Download', '', "Downloading file '%s'..." % file_name.split('/')[-1:][0])
            cfg.progress_bar.update_progress_message('Initializing...')
            cfg.output_queue.append(
                DownloadMessage(node.to_text(), cfg.shm.download_from_file(file_name), display=cfg.display_state,
                                generate_rdf=cfg.generate_rdf))
            cfg.progress_bar.stop_animation()
        except MemoryError as e:
            cfg.progress_bar.stop_animation()
            raise EvaluationError(e, node.source_info)
        except BaseException:
            cfg.progress_bar.stop_animation()
            raise

    cpdef visitUpload(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.set_mask(cfg.global_mask)
        try:
            start_address = self.visit(node.start_address)
            end_address = self.visit(node.end_address)
            self.address_validator(node, start_address, end_address)
            file_name = cfg.config_file.get_uploadpath(str(self.visit(node.file_name)))
            cfg.progress_bar.start_animation('Upload', '',
                                             "Uploading to files '%s.chX'..." % file_name.split('/')[-1:][0])
            cfg.progress_bar.update_progress_message('Initializing...')
            cfg.output_queue.append(UploadMessage(node.to_text(), cfg.shm.upload_to_file(start_address, end_address,
                                                                                         file_name),
                                                  display=cfg.display_state, generate_rdf=cfg.generate_rdf))
            cfg.progress_bar.stop_animation()
        except MemoryError as e:
            cfg.progress_bar.stop_animation()
            raise EvaluationError(e, node.source_info)
        except BaseException:
            cfg.progress_bar.stop_animation()
            raise

    cpdef visitVerify(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()

        cfg.shm.set_mask(cfg.global_mask)
        try:
            start_address = self.visit(node.start_address)
            end_address = self.visit(node.end_address)
            self.address_validator(node, start_address, end_address)
            file_name = cfg.config_file.get_downloadpath(str(self.visit(node.file_name)))
            cfg.progress_bar.start_animation('Verify', '',
                                             "Verifying against file '%s'..." % file_name.split('/')[-1:][0])
            cfg.progress_bar.update_progress_message('Initializing...')
            verify_completed = False
            result = cfg.shm.verify_memory(start_address, end_address, file_name)
            verify_completed = True
            cfg.progress_bar.stop_animation()
            for channnel in xrange(4):
                try:
                    diffs[channnel] = result['channels'][channnel]['differences']
                except TypeError:
                    diffs[channnel] = result['channels'][channnel]

            cfg.output_queue.append(
                VerifyMessage(node.to_text(), result, display=cfg.display_state, generate_rdf=cfg.generate_rdf))
        except MemoryError as e:
            cfg.progress_bar.stop_animation()
            raise EvaluationError(e, node.source_info)
        except BaseException:
            cfg.progress_bar.stop_animation()
            raise

    cpdef visitDchan(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        mask = int(self.visit(node.global_mask))

        if mask not in xrange(16):
            raise EvaluationError("Invalid range for global mask value, should be "
                                  "in range [0, 15]", node.source_info)

        cfg.global_mask = mask
        cfg.output_queue.append(NormalMessage(node.to_text(),
                                              ("Global mask set using dchan to '%s'." % bin(cfg.global_mask)),
                                              display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef to_readable_size(self, storage_used):
        if storage_used in xrange(0, 1024):
            return "%.1f B" % storage_used
        elif storage_used in xrange(1024, 1048576):
            return "%.1f KiB" % (storage_used / 1024.0)
        elif storage_used in xrange(1048576, 1073741824):
            return "%.1f MiB" % (storage_used / 1048576.0)
        elif storage_used in xrange(1073741824, 1099511627776L):
            return "%.1f GiB" % (storage_used / 1073741824.0)
        else:
            return "%.1f ERROR" % storage_used

    cpdef visitExpand(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            entry_list = map(cfg.symbol_table.get_entry, node.expand_list)

            for e in entry_list:
                cfg.output_queue.append(NormalMessage(node.to_text(), (
                    "%s%s\n%s" % (e.name, '*' if (e.get_type() == TokenType.TYP_FUNC) and not e.node.silent else '',
                                  '' * (len(e.name) + (
                                      1 if (e.get_type() == TokenType.TYP_FUNC) and not e.node.silent else 0)))),
                                                      display=cfg.display_state, generate_rdf=cfg.generate_rdf))

                if isinstance(e, Function):
                    statements = e.node.stmt.get_statements()
                elif isinstance(e, Macro):
                    statements = e.expand().get_statements()
                else:
                    raise EvaluationError('Can expand only macros/functions', node.source_info)

                for s in statements:
                    if isinstance(s, tree.InputListing):
                        cfg.output_queue.append(
                            ListingMessage(s.to_text(), s.text, display=True, generate_rdf=cfg.generate_rdf))
        except KeyError:
            raise EvaluationError('Macro/function not loaded', node.source_info)

    cpdef visitList(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        total_match_count = 0
        total_match_size = 0
        source_count = 0
        sources = cfg.symbol_table.get_external_sources()
        sources.sort()

        try:
            if (len(node.filename_pattern) == 0) and (len(node.name_pattern) == 0):
                cfg.output_queue.append(NormalMessage(node.to_text(), "Listing all loaded files...\n"
                                                                      "For matching names use one of the following syntax:\n"
                                                                      "  list <name_pattern>\n"
                                                                      "  list <filename_pattern> : <name_pattern>\n",
                                                      display=cfg.display_state, generate_rdf=cfg.generate_rdf))
                for a_source in sources:
                    source_count += 1
                    cfg.output_queue.append(NormalMessage(node.to_text(), ("  File '%s'" % a_source),
                                                          display=cfg.display_state, generate_rdf=cfg.generate_rdf))
                cfg.output_queue.append(
                    NormalMessage(node.to_text(), ("Listed %d source(s)." % source_count), display=cfg.display_state,
                                  generate_rdf=cfg.generate_rdf))
            else:
                cfg.output_queue.append(NormalMessage(node.to_text(), "Listing all matching names...\n"
                                                                      "For a list of loaded files use the following syntax:\n"
                                                                      "  list\n",
                                                      display=cfg.display_state, generate_rdf=cfg.generate_rdf))
                for a_source in sources:
                    if match(node.filename_pattern, a_source):
                        source_count += 1
                        cfg.output_queue.append(NormalMessage(node.to_text(), (
                            "  From file '%s'\n     %35s %19s %9s\n     %35s %19s %9s" % (
                                a_source, "NAME", "TYPE", "SIZE", "" * 35, "" * 19, "" * 9)),
                                                              display=cfg.display_state, generate_rdf=cfg.generate_rdf))
                        names = cfg.symbol_table.get_names_from(a_source)
                        names.sort()
                        match_count = 0
                        match_size = 0
                        for a_name in names:
                            if match(node.name_pattern, a_name):
                                match_count += 1
                                match_size = match_size + cfg.symbol_table.get_entry(a_name).get_size()
                                cfg.output_queue.append(
                                    NormalMessage(node.to_text(), ("     %s" % (cfg.symbol_table.get_entry(a_name))),
                                                  display=cfg.display_state, generate_rdf=cfg.generate_rdf))
                        total_match_count += match_count
                        total_match_size += match_size
                        if match_count == 0:
                            source_count -= 1
                            cfg.output_queue.pop()  # Remove file name if there are no matching symbols in that file
                        else:
                            cfg.output_queue.append(NormalMessage(node.to_text(), (
                                "  %d name(s) of total size %s." % (match_count, self.to_readable_size(match_size))),
                                                                  display=cfg.display_state,
                                                                  generate_rdf=cfg.generate_rdf))
                cfg.output_queue.append(NormalMessage(node.to_text(), (
                    "Listed %d name(s) of total size %s from %d source(s)." % (
                        total_match_count, self.to_readable_size(total_match_size), source_count)),
                                                      display=cfg.display_state,
                                                      generate_rdf=cfg.generate_rdf))
        except KeyError:
            raise EvaluationError('Corrupted symbol table, please check your configuration', node.source_info)
        except:
            raise EvaluationError('Syntax error in list expression', node.source_info)

    cpdef visitOpMsg(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.output_queue.append(
            NormalMessage(node.to_text(), node.message, display=cfg.display_state, generate_rdf=cfg.generate_rdf))
        output.print_output_queue()

    cpdef visitOpWait(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        output.print_output_queue()
        while True:
            choice = raw_input("User Action %s? (Y/N): " % str(node.message))

            if choice.lower() == 'y':
                cfg.output_queue.append(NormalMessage(node.to_text(), node.message \
                                                      + ': Yes.', display=False, generate_rdf=cfg.generate_rdf))
                break
            elif choice.lower() == 'n':
                cfg.output_queue.append(NormalMessage(node.to_text(), node.message \
                                                      + ': No.', display=False, generate_rdf=cfg.generate_rdf))
                raise UserExitError('Script terminated', node.source_info)

    cpdef visitExit(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        raise ExitError('Script terminated', node.source_info)

    cpdef visitAssert(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if not self.visit(node.expr):
            raise AssertError("'%s', %s" % (node.expr.to_text(), node.message),
                              node.source_info)

    cpdef visitLocate(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            for loc_name in node.loc_list:
                filename = 'unknown'
                line_no = 'unknown'
                try:
                    filename = cfg.symbol_table.get_entry(loc_name).source_info.get_name()
                    line_no = cfg.symbol_table.get_entry(loc_name).source_info.get_lineno()
                except AttributeError:
                    pass
                cfg.output_queue.append(NormalMessage(node.to_text(), (
                    "%s\n%s\n  From file '%s' at line %s" % (loc_name, '' * len(loc_name), filename, line_no)),
                                                      display=cfg.display_state, generate_rdf=cfg.generate_rdf))
        except KeyError as e:
            message = "Unknown name %s, not a variable or symbol" % e
            raise EvaluationError(message, node.source_info)

    cpdef visitDelete(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            map(cfg.symbol_table.del_entry, node.del_list)
        except KeyError as e:
            message = "Unknown name %s, not a variable or symbol" % e
            raise EvaluationError(message, node.source_info)
        except TypeError:
            message = "Cannot delete system functions"
            raise EvaluationError(message, node.source_info)

    cpdef visitDisplay(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.display_state = bool(self.visit(node.expr))

    cpdef visitLogging(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.logging_state = bool(self.visit(node.expr))

    cpdef visitPrintSymbol(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.expr, (), {'bypass': False})
        value['compare'] = [('unused' if v == 'unused' else True) for v in value['value']]

        return value

    cpdef visitPrintBypassSymbol(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        value = self.visit(node.expr, (), {'bypass': True})
        value['compare'] = [('unused' if v == 'unused' else True) for v in value['value']]

        return value

    def visitSPILSymbolStatementList(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values

        self.spil_prefetch_flag = True
        self.spil_prefetch_list = []

        try:
            result_list = map(self.visitor_method, node.children)
        except TypeError:
            raise EvaluationError("Symbol: Incompatible operand type", node.source_info)
        except AttributeError as e:
            raise EvaluationError("%s" % e, node.source_info)

        self.spil_prefetch_flag = False
        try:
            cfg.shm.wait_for_transition()
            cfg.shm.prefetch_spil(self.spil_prefetch_list)
        except MemoryError as e:
            raise EvaluationError(e, node.source_info)

        result_list = map(self.visitor_method, node.children)

        # For final value, above code shifted here, after evalaution
        command_list = [n.to_text() for n in node.children]
        command_list = [("%s &" % c) for c in command_list[:-1]] + command_list[-1:]

        system_channel_values = [(r['value']) for r in result_list]
        value_list = [(r['compare']) for r in result_list]  #map(lambda v: v['value'], result_list)
        value = all([all(filter(lambda vi: vi != 'unused', v)) for v in value_list])
        cfg.output_queue.append(
            SymbolMessage(command_list, result_list, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

        return value

    def visitRS422SymbolStatementList(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values

        cfg.shm.wait_for_transition()

        self.rs422_node_list = []

        try:
            result_list = map(self.visitor_method, node.children)
        except TypeError:
            raise EvaluationError("Symbol: Incompatible operand type", node.source_info)
        except AttributeError as e:
            raise EvaluationError("%s" % e, node.source_info)

        cfg.shm.switch_buffers(self.rs422_node_list)
        cfg.shm.reset_active_buffer_lookup()

        # For final value, above code shifted here, after evalaution
        command_list = [n.to_text() for n in node.children]
        command_list = [("%s &" % c) for c in command_list[:-1]] + command_list[-1:]

        system_channel_values = [(r['value']) for r in result_list]
        value_list = [(r['compare']) for r in result_list]  #map(lambda v: v['value'], result_list)

        value = all([all(filter(lambda vi: vi != 'unused', v)) for v in value_list])

        cfg.output_queue.append(
            SymbolMessage(command_list, result_list, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

        return value

    def visitSymbolStatementList(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cdef dict result
        cdef list value_list = []
        cdef list result_list = []
        cdef list command_list = []
        cdef list children = node.children
        cdef bool value
        cdef unsigned int i
        global system_channel_values

        cfg.shm.wait_for_transition()

        try:
            system_channel_values = []
            for child in children:
                result = self.visit(child)
                result_list.append(result)
                system_channel_values.append(result['value'])
                value_list.append(result['compare'])
                command_list.append(child.to_text() + ' &')

            command_list[-1] = command_list[-1][:-1]
            value = all([all(filter(lambda vi: vi != 'unused', v)) for v in value_list])
        except TypeError as e:
            raise EvaluationError("Symbol: Incompatible operand type" + str(e), node.source_info)
        except AttributeError as e:
            raise EvaluationError("%s" % e, node.source_info)

        cfg.output_queue.append(
            SymbolMessage(command_list, result_list, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

        return value

    cpdef visitFunction(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if args:
            try:
                # Mod8: begin
                if node.silent:
                    curr_output_queue_size = len(cfg.output_queue)  # Save current output queue length
                # Mod8: end
                result = self.visit(node.stmt)
                # Mod8: begin
                if node.silent:
                    cfg.output_queue = cfg.output_queue[:curr_output_queue_size]  # Remove new items in queue
                # Mod8: end
                return result
            except ReturnValue as (v, t):
                # Mod8: begin
                if node.silent:
                    cfg.output_queue = cfg.output_queue[:curr_output_queue_size]  # Remove new items in queue
                # Mod8: end
                return v['value']
            except RuntimeError:
                raise EvaluationError("Maximum recursion depth exceeded in function call", node.source_info)

    cpdef visitFunctionSystem(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        returncode = 0

        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'system' expects exactly one parameter", node.source_info)

        try:
            cmd_str = self.visit(node.param_lst[1]).strip()
        except AttributeError:  # TypeError:
            raise EvaluationError("Function 'system' expects parameter of type 'string'", node.source_info)

        if len(cmd_str) > 0:
            try:
                returncode = subprocess.call(cmd_str.split())
            except BaseException as e:
                raise EvaluationError("system('%s'): '%s'" % (cmd_str, e), node.source_info)

        return returncode

    cpdef visitFunctionStr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'str' expects exactly one parameter", node.source_info)
        return '%s' % self.visit(node.param_lst[1])

    cpdef visitFunctionHex(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'hex' expects exactly one parameter", node.source_info)

        return '%s' % hex(self.visit(node.param_lst[1]))

    cpdef visitFunctionOct(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'oct' expects exactly one parameter", node.source_info)

        oct_string = oct(self.visit(node.param_lst[1]))
        if oct_string[0] == '-':
            return '-0o%s' % oct_string[2:]
        else:
            return '0o%s' % oct_string[1:]

    cpdef visitFunctionBin(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'bin' expects exactly one parameter", node.source_info)
        return '%s' % bin(self.visit(node.param_lst[1]))

    cpdef visitFunctionLeftShift(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'left_shift' expects exactly two parameters", node.source_info)
        return self.visit(node.param_lst[1]) << self.visit(node.param_lst[2])

    cpdef visitFunctionRightShift(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'right_shift' expects exactly two parameters", node.source_info)
        return self.visit(node.param_lst[1]) >> self.visit(node.param_lst[2])

    cpdef visitFunctionBitAnd(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'bit_and' expects exactly two parameters", node.source_info)
        return self.visit(node.param_lst[1]) & self.visit(node.param_lst[2])

    cpdef visitFunctionBitOr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'bit_or' expects exactly two parameters", node.source_info)
        return self.visit(node.param_lst[1]) | self.visit(node.param_lst[2])

    cpdef visitFunctionBitXor(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'bit_xor' expects exactly two parameters", node.source_info)
        return self.visit(node.param_lst[1]) ^ self.visit(node.param_lst[2])

    cpdef visitFunctionPow(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'pow' expects exactly two parameters", node.source_info)
        return self.visit(node.param_lst[1]) ** self.visit(node.param_lst[2])

    cpdef visitFunctionTime(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) > 0:
            raise EvaluationError("Function 'time' expects no parameters", node.source_info)
        return time()

    cpdef visitFunctionSin(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'sin' expects exactly one parameter", node.source_info)
        return sin(self.visit(node.param_lst[1]))

    cpdef visitFunctionCos(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'cos' expects exactly one parameter", node.source_info)
        return cos(self.visit(node.param_lst[1]))

    cpdef visitFunctionTan(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'tan' expects exactly one parameter", node.source_info)
        return tan(self.visit(node.param_lst[1]))

    cpdef visitFunctionInputInt(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        output.print_output_queue()
        if self.visit(node.param_lst[0]) not in (0, 1):
            raise EvaluationError("Function 'input_int' expects either zero or one parameter", node.source_info)

        try:
            if self.visit(node.param_lst[0]) == 1:
                return int(raw_input(self.visit(node.param_lst[1])))
            else:
                return int(raw_input())
        except ValueError:
            raise EvaluationError("Malformed input for function 'input_int'", node.source_info)

    cpdef visitFunctionInputFloat(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        output.print_output_queue()
        if self.visit(node.param_lst[0]) not in (0, 1):
            raise EvaluationError("Function 'input_float' expects either zero or one parameter", node.source_info)

        try:
            if self.visit(node.param_lst[0]) == 1:
                return float(raw_input(self.visit(node.param_lst[1])))
            else:
                return float(raw_input())
        except ValueError:
            raise EvaluationError("Malformed input for function 'input_float'", node.source_info)

    cpdef visitFunctionInputStr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        output.print_output_queue()
        if self.visit(node.param_lst[0]) not in (0, 1):
            raise EvaluationError("Function 'input_str' expects either zero or one parameter", node.source_info)
        if self.visit(node.param_lst[0]) == 1:
            return str(raw_input(self.visit(node.param_lst[1])))
        else:
            return str(raw_input())

    cpdef visitFunctionInit1553B(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'init_1553b' expects exactly one parameter", node.source_info)

        try:
            # Mod3: begin
            filename = self.visit(node.param_lst[1])
            filename = os.path.expanduser(filename)

            if filename.startswith('./'):
                filename = "%s/%s" % (os.getcwd(), filename[2:])

            status = cfg.shm.init1553b(filename)
            # Mod3: end
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

        if status['bus1']['processed']:
            cfg.output_queue.append(NormalMessage(node.to_text(),
                                                  "Bus 1: Processed %d message(s) in %d minor frame(s)" % (
                                                      status['bus1']['messages'], status['bus1']['frames']),
                                                  display=cfg.display_state, generate_rdf=cfg.generate_rdf))
        if status['bus2']['processed']:
            cfg.output_queue.append(NormalMessage(node.to_text(),
                                                  "Bus 2: Processed %d message(s) in %d minor frame(s)" % (
                                                      status['bus2']['messages'], status['bus2']['frames']),
                                                  display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitFunctionMessageMsgType(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'message_msgtype' expects exactly two parameters", node.source_info)

        try:
            return cfg.shm.message_msgtype(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitFunctionMessageRTAddr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 3:
            raise EvaluationError("Function 'message_rtaddr' expects exactly three parameters", node.source_info)

        try:
            index = self.visit(node.param_lst[3])
            if index == 1:
                return cfg.shm.message_rtaddr1(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
            else:
                return cfg.shm.message_rtaddr2(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitFunctionMessageRTSubAddr(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 3:
            raise EvaluationError("Function 'message_rtsubaddr' expects exactly three parameters", node.source_info)

        try:
            index = self.visit(node.param_lst[3])
            if index == 1:
                return cfg.shm.message_rtsubaddr1(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
            else:
                return cfg.shm.message_rtsubaddr2(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitFunctionMessageWCntMCode(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'message_wcntmcode' expects exactly two parameters", node.source_info)

        try:
            return cfg.shm.message_wcntmcode(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitFunctionMessageMsgGap(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'message_msggap' expects exactly two parameters", node.source_info)

        try:
            return cfg.shm.message_msggap(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitFunctionMessageInfo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'message_info' expects exactly two parameters", node.source_info)

        try:
            return cfg.shm.message_info(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitFunctionMessageGap(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'message_gap' expects exactly two parameters", node.source_info)

        try:
            return cfg.shm.message_gap(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitFunctionMessageDefined(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'message_defined' expects exactly two parameters", node.source_info)

        try:
            return cfg.shm.message_defined(self.visit(node.param_lst[1]), self.visit(node.param_lst[2]))
        except MemoryError as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitFunctionFileAccess(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 2:
            raise EvaluationError("Function 'file_access' expects exactly two parameters", node.source_info)

        try:
            mode = int(self.visit(node.param_lst[2]))
        except ValueError as e:
            raise EvaluationError("Error in second (mode) parameter for function 'file_access'", node.source_info)

        if mode == 0:  # check for existence
            return os.access(self.visit(node.param_lst[1]), os.F_OK)
        elif mode == 1:  # check for read permission
            return os.access(self.visit(node.param_lst[1]), os.R_OK)
        elif mode == 2:  # check for write permission
            return os.access(self.visit(node.param_lst[1]), os.W_OK)
        elif mode == 3:  # check for read and write permission
            return os.access(self.visit(node.param_lst[1]), os.R_OK | os.W_OK)
        else:
            raise EvaluationError("Invalid value for mode in function 'file_access'", node.source_info)

    cpdef visitFunctionFileDownloadPath(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) not in (0, 1):
            raise EvaluationError("Function 'file_downloadpath' expects either zero or one parameter", node.source_info)
        if self.visit(node.param_lst[0]) == 1:
            if len(str(self.visit(node.param_lst[1]))) > 0:
                return cfg.config_file.get_downloadpath(str(self.visit(node.param_lst[1])))
            else:
                return cfg.config_file.get_value('downloadpath')
        else:
            return cfg.config_file.get_value('downloadpath')

    cpdef visitFunctionFileUploadPath(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) not in (0, 1):
            raise EvaluationError("Function 'file_uploadpath' expects either zero or one parameter", node.source_info)
        if self.visit(node.param_lst[0]) == 1:
            if len(str(self.visit(node.param_lst[1]))) > 0:
                return cfg.config_file.get_uploadpath(str(self.visit(node.param_lst[1])))
            else:
                return cfg.config_file.get_value('uploadpath')
        else:
            return cfg.config_file.get_value('uploadpath')

    cpdef visitFunctionGetUUT(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 0:
            raise EvaluationError("Function 'get_uut' expects no parameters", node.source_info)
        else:
            # Dynamic configuration for ADC/LADC 21/11/2013 
            if cfg.config_file.is_configured_for_ADC():
                return 'adc'
            elif cfg.config_file.is_configured_for_DFCC():
                return 'dfcc'
            elif cfg.config_file.is_configured_for_DFCC_MK2():
                return 'dfcc_mk2'
            else:  # defaults to LADC
                return 'ladc'

    cpdef visitFunctionGetVersion(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 0:
            raise EvaluationError("Function 'get_version' expects no parameters", node.source_info)
        else:
            return cfg.aitess_version_long

    cpdef visitFunctionGetWdm(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global wdm_address
        if self.visit(node.param_lst[0]) > 0:
            raise EvaluationError("Function 'get_wdm' expects no parameters", node.source_info)
        return wdm_address

    cpdef visitFunctionSetWdm(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global wdm_address
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'set_wdm' expects exactly one parameter", node.source_info)
        wdm_address = self.visit(node.param_lst[1])

    cpdef visitFunctionFrameNumber(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) > 0:
            raise EvaluationError("Function 'frame_number' expects no parameters", node.source_info)
        return cfg.shm.get_frame_number()

    cpdef visitFunctionChannelEnabled(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if self.visit(node.param_lst[0]) != 1:
            raise EvaluationError("Function 'channel_enabled' expects exactly one parameter", node.source_info)

        channel_number = self.visit(node.param_lst[1])

        if channel_number not in xrange(1, 5):
            raise EvaluationError("Channel number should be one of 1, 2, 3 or 4", node.source_info)

        return bool(cfg.global_mask & (0b1000 >> (channel_number - 1)))

    cpdef visitFunctionInRange(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        visitor = self.visitor_method
        parameters = map(visitor, node.param_lst)
        if parameters[0] != 3:
            raise EvaluationError("Function 'in_range' expects exactly three parameters", node.source_info)
        return parameters[2] <= parameters[1] <= parameters[3]

    cpdef visitFunctionChannelValue(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        global system_channel_values
        visitor = self.visitor_method
        parameters = map(visitor, node.param_lst)

        if parameters[0] not in (0, 2):
            raise EvaluationError("Function 'channel_value' expects either zero or two parameters", node.source_info)

        if parameters[0] == 0:
            return len(system_channel_values)

        if (parameters[1] < 1) or (parameters[2] < 1):
            raise EvaluationError("Both parameter values should be greater than zero for function 'channel_value'",
                                  node.source_info)

        try:
            return system_channel_values[parameters[1] - 1][parameters[2] - 1]
        except IndexError:
            raise EvaluationError("Parameter value range exceeded for function 'channel_value'", node.source_info)
        except TypeError:
            raise EvaluationError("Function 'channel_value' expects integer parameters", node.source_info)

    cpdef visitFunctionInvocation(self, node, tuple args=(), kargs=None):
        # Evaluate all parameters before passing them  to the function
        if kargs is None:
            kargs = {}
        visitor = self.visitor_method
        param_lst = node.param_lst

        try:
            dynamic_object = cfg.symbol_table.get_entry(node.name)
        except KeyError:
            message = "Unknown name '%s', implicitly used as a function" % node.name
            raise EvaluationError(message, node.source_info)

        if isinstance(dynamic_object, Function):
            func_subtree = dynamic_object.node
        else:
            message = "Previously implicit function '%s' defined as type '%s'" % \
                      (node.name, dynamic_object.__class__.__name__.lower())
            raise EvaluationError(message, node.source_info)

        self.function_stack.append([SymbolTable()] + map(visitor, param_lst))
        try:
            return visitor(func_subtree, (True,))
        except:
            raise
        finally:
            self.function_stack.pop()

    cpdef visitParameterNumber(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            param_number = self.visit(node.number)
            # All parameters are already evaluated, use them as they are accessed within the function
            return self.function_stack[-1][param_number + 1]
        except IndexError:
            raise EvaluationError("Attempt to access invalid parameter number $(%d)" % param_number, node.source_info)

    cpdef visitLocalIdentifier(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        try:
            value = kargs['value']
            if type(value) is str:
                self.function_stack[-1][0].put_entry(node.name, StringVariable(node.name, value, node.source_info))
            else:
                self.function_stack[-1][0].put_entry(node.name, NumericVariable(node.name, value, node.source_info))
        except KeyError:
            try:
                value = self.function_stack[-1][0].get_entry(node.name).read()
            except KeyError:
                message = "Unknown scoped name '$%s', not a variable or symbol" % node.name
                raise EvaluationError(message, node.source_info)

        return value

    cpdef visitReturn(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        if node.expr is None:
            value = None
        else:
            value = self.visit(node.expr)
        raise ReturnValue({'value': value}, type(value))

    cpdef visitStatement(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cdef list stmt_list = node.stmt_list
        for stmt in stmt_list:
            self.visit(stmt)

    cpdef visitMacroInvocation(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.output_queue.append(NormalMessage(node.to_text(), '', display=False, generate_rdf=cfg.generate_rdf))
        self.visit(node.entry.expand())

    cpdef visitPass(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        cfg.shm.wait_for_transition()

    cpdef visitPatch(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        channel_number = self.visit(node.channel_number_expr)
        if not channel_number in (1, 2, 3, 4):
            raise EvaluationError("Invalid range for channel number, should be "
                                  "in range [1, 4]", node.source_info)

        try:
            now = datetime.datetime.now()
            f = tempfile.NamedTemporaryFile(mode='w+t', bufsize=-1, suffix='.tpf', prefix='patch_on_%s_at_%s' % (
                now.strftime("%d_%m_%Y"), now.strftime("%H_%M")), dir=cfg.config_file.get_value('tpfpath'),
                                            delete=False)
        except IOError as e:
            raise EvaluationError("Patch output file '%s' I/O error, %s" \
                                  % (f.name, e.strerror.lower()), node.source_info)
        # Mod10: begin
        else:
            try:
                os.chown(f.name, int(os.getenv("SUDO_UID")), int(os.getenv("SUDO_GID")))
            except TypeError:  # If we are not running under "sudo", environment variables "SUDO_GID" and
                pass  # "SUDO_GID" will not be set and there is no point in changing the ownership
        # Mod10: end


        try:
            if diffs[channel_number - 1] == 'unused':
                f.write(
                    "print 'Nothing to patch on channel %d; it was unused.' ! specified channel is unused\n" % channel_number)
            else:
                if len(diffs[channel_number - 1]) == 0:
                    f.write(
                        "print 'Nothing to patch on channel %d; it has no differing addresses.' ! specified channel has no differing addresses\n" % channel_number)
                elif len(diffs[channel_number - 1]) > 32:
                    raise EvaluationError("Patch file not generated, too many locations (>32) to patch",
                                          node.source_info)
                else:
                    f.write(
                        "dchan = %04d\nprg_mem_enb = 1\nmacname = eeprom_sdp_disable\nprint 'Patching channel %d...'\n" % (
                            int(bin(0b1 << (4 - channel_number))[2:]), channel_number))
                    for address in diffs[channel_number - 1]:
                        f.write('tip # mrhrp %11s %11s ! now address %11s has data %11s\n' % (
                            hex(address)[2:].split('L')[0],
                            hex(diffs[channel_number - 1][address][1])[2:].split('L')[0],
                            hex(address).split('L')[0], hex(diffs[channel_number - 1][address][0]).split('L')[0]))
                    f.write("macname = eeprom_sdp_enable\nprg_mem_enb = 0\ndchan = 1111\n")
        except IOError as e:
            raise EvaluationError("Patch output file '%s' I/O error, %s" \
                                  % (f.name, e.strerror.lower()), node.source_info)
        finally:
            f.close()

        cfg.output_queue.append(
            NormalMessage(node.to_text(), "Patch file '%s' written" % f.name, display=cfg.display_state,
                          generate_rdf=cfg.generate_rdf))

    cpdef visitDiffs(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        channel_number = self.visit(node.channel_number_expr)
        if not channel_number in (1, 2, 3, 4):
            raise EvaluationError("Invalid range for channel number, should be "
                                  "in range [1, 4]", node.source_info)

        if diffs[channel_number - 1] == 'unused':
            output_str = 'unused'
        else:
            if len(diffs[channel_number - 1]) == 0:
                output_str = 'No differences in selected channel'
            else:
                output_str = '%s%11s   %11s %11s%s' % (cfg.WHITE, 'Address', 'Found', 'Expected', cfg.COLOR_END)
                addresses = diffs[channel_number - 1].keys()
                addresses.sort()
                for address in addresses:
                    output_str = '%s\n%s%11s%s : %s%11s%s %s%11s%s' % (
                        output_str, cfg.WHITE, hex(address).split('L')[0], cfg.COLOR_END, cfg.RED,
                        hex(diffs[channel_number - 1][address][0]).split('L')[0], cfg.COLOR_END, cfg.GREEN,
                        hex(diffs[channel_number - 1][address][1]).split('L')[0], cfg.COLOR_END)

        cfg.output_queue.append(
            NormalMessage(node.to_text(), output_str, display=cfg.display_state, generate_rdf=cfg.generate_rdf))

    cpdef visitInfo(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        nil_text = cfg.RED + 'nil' + cfg.COLOR_END
        try:
            e = cfg.symbol_table.get_entry(node.info_name)
        except KeyError:
            message = "Unknown name '%s', not a variable, symbol, function or macro" % node.info_name
            raise EvaluationError(message, node.source_info)

        try:
            if e.get_type() == TokenType.TYP_SYMBOL:
                cfg.output_queue.append(NormalMessage(node.to_text(), (
                    "%s\n%s\n  From file '%s' at line %s\n"
                    "     class                       = symbol:%s\n"
                    "     iotype                      = %s\n"
                    "     chan                        = %s\n"
                    "     addr                        = %s\n"
                    "     dtype                       = %s\n"
                    "     min, max                    = %s, %s\n"
                    "     subsystem                   = %s\n"
                    "     struct                      = %s\n"
                    "     stype                       = %s\n"
                    "     ofst1, ofst2, ofst3, ofst4  = %s, %s, %s, %s\n"
                    "     slpe, bias                  = %s%s, %s%s\n"
                    "     read, wrte                  = %s, %s\n"
                    "     dest                        = %s\n"
                    "     mask                        = %s\n"
                    "     tolminus, tolplus           = %s, %s\n"
                    "     id                          = %s\n"
                    "     ofst                        = %s\n"
                    "     mask1, mask2, mask3, mask4  = %s, %s, %s, %s\n"
                    "     size                        = %s" % (e.name, '' * len(e.name),
                                                               e.source_info.get_name(), e.source_info.get_lineno(),
                                                               e.iotype if e.iotype is not None else nil_text,
                                                               e.iotype if e.iotype is not None else nil_text,
                                                               bin(e.chan) if e.chan is not None else nil_text,
                                                               hex(e.addr).split('L')[
                                                                   0] if e.addr is not None else nil_text,
                                                               e.dtype if e.dtype is not None else nil_text,
                                                               e.min_ if e.min_ is not None else nil_text,
                                                               e.max_ if e.max_ is not None else nil_text,
                                                               e.subsystem if e.subsystem is not None else nil_text,
                                                               e.struct_ if e.struct_ is not None else nil_text,
                                                               e.stype if e.stype is not None else nil_text,
                                                               e.ofst1 if e.ofst1 is not None else nil_text,
                                                               e.ofst2 if e.ofst2 is not None else nil_text,
                                                               e.ofst3 if e.ofst3 is not None else nil_text,
                                                               e.ofst4 if e.ofst4 is not None else nil_text,
                                                               e.slpe if e.slpe is not None else nil_text,
                                                               (" (%s)" % e.slpe_text) if len(e.slpe_text) else "",
                                                               e.bias if e.bias is not None else nil_text,
                                                               (" (%s)" % e.bias_text) if len(e.bias_text) else "",
                                                               bin(e.read) if e.read is not None else nil_text,
                                                               bin(e.wrte) if e.wrte is not None else nil_text,
                                                               e.dest if e.dest is not None else nil_text,
                                                               hex(e.mask).split('L')[
                                                                   0] if e.mask is not None else nil_text,
                                                               e.tolminus if e.tolminus is not None else nil_text,
                                                               e.tolplus if e.tolplus is not None else nil_text,
                                                               e.id_ if e.id_ is not None else nil_text,
                                                               hex(e.ofstx).split('L')[
                                                                   0] if e.ofstx is not None else nil_text,
                                                               hex(e.mask1).split('L')[
                                                                   0] if e.mask1 is not None else nil_text,
                                                               hex(e.mask2).split('L')[
                                                                   0] if e.mask2 is not None else nil_text,
                                                               hex(e.mask3).split('L')[
                                                                   0] if e.mask3 is not None else nil_text,
                                                               hex(e.mask4).split('L')[
                                                                   0] if e.mask4 is not None else nil_text,
                                                               e.get_readable_size())),
                                                      display=cfg.display_state, generate_rdf=cfg.generate_rdf))
            elif e.get_type() == TokenType.TYP_VARIABLE:
                cfg.output_queue.append(NormalMessage(node.to_text(), (
                    "%s\n%s\n  From file '%s' at line %s\n"
                    "     class       = variable:%s\n"
                    "     value       = %s%s%s\n"
                    "     type        = %s\n"
                    "     size        = %s" %
                    (e.name, '' * len(e.name), e.source_info.get_name(),
                     e.source_info.get_lineno(), e.get_data_type(), "'" if e.get_data_type() == 'string' else "",
                     str(e.value), "'" if e.get_data_type() == 'string' else "", e.get_data_type(),
                     e.get_readable_size())), display=cfg.display_state, generate_rdf=cfg.generate_rdf))
            elif e.get_type() == TokenType.TYP_MACRO:
                cfg.output_queue.append(NormalMessage(node.to_text(), (
                    "%s\n%s\n  From file '%s' at line %s\n"
                    "     class       = macro\n"
                    "     size        = %s" % (
                        e.name, '' * len(e.name), e.source_info.get_name(), e.source_info.get_lineno(),
                        e.get_readable_size())), display=cfg.display_state, generate_rdf=cfg.generate_rdf))
            elif e.get_type() == TokenType.TYP_SYSFUNC:
                cfg.output_queue.append(NormalMessage(node.to_text(), (
                    "%s\n%s\n  From file '%s' at line %s\n"
                    "     class       = function:system\n"
                    "     size        = %s" %
                    (e.name, '' * len(e.name), e.source_info.get_name(),
                     e.source_info.get_lineno(), e.get_readable_size())),
                                                      display=cfg.display_state, generate_rdf=cfg.generate_rdf))
            elif e.get_type() == TokenType.TYP_FUNC:
                cfg.output_queue.append(NormalMessage(node.to_text(), (
                    "%s\n%s\n  From file '%s' at line %s\n"
                    "     class       = function:user\n"
                    "     silent      = %s\n"
                    "     size        = %s" %
                    (e.name, '' * len(e.name), e.source_info.get_name(),
                     e.source_info.get_lineno(), 'yes' if e.node.silent else 'no',
                     e.get_readable_size())),
                                                      display=cfg.display_state, generate_rdf=cfg.generate_rdf))
        except BaseException as e:
            raise EvaluationError(str(e), node.source_info)

    cpdef visitProgram(self, node, tuple args=(), kargs=None):
        if kargs is None:
            kargs = {}
        t = time()
        if node.rdfname and (len(cfg.rdf_filename) == 0):
            cfg.generate_rdf = True
            cfg.rdf_filename = node.rdfname
            # If RDF is generated in the directory specified in config.dat then don't print the path of RDF
            if os.path.dirname(cfg.rdf_filename) == os.path.dirname(cfg.config_file.get_rdfpath('')):
                sys.stdout.write(
                    "Running TPF '" + cfg.GREEN + node.name + cfg.COLOR_END + "' and generating RDF '" + cfg.GREEN +
                    cfg.rdf_filename.split('/')[-1] + cfg.COLOR_END + "'.\n")
            else:  # else print the path of RDF
                sys.stdout.write(
                    "Running TPF '" + cfg.GREEN + node.name + cfg.COLOR_END + "' and generating RDF '" + cfg.GREEN +
                    cfg.rdf_filename + cfg.COLOR_END + "'.\n")
            sys.stdout.flush()
            # Mod6: begin
            cfg.output_queue.append(
                ProgramMessage(node.name, cfg.rdf_filename, display=True, generate_rdf=cfg.generate_rdf))
            # Mod6: end

        self.visit(node.child)

        if cfg.generate_rdf and (cfg.rdf_filename == node.rdfname):
            cfg.generate_rdf = False
            # Shifted RDF filename clearing to output.pyx print_output_queue() function
            # so that we can generate an RDF before clearing the RDF filename.
            # Mod5: begin
            if node.rdf_error_flag == 1:
                cfg.output_queue.append(NormalMessage(None,
                                                      cfg.BRIGHT_PINK + "Warning: RDF file version impossible to determine based on the file name pattern, will append to file with version 00." + cfg.COLOR_END,
                                                      display=True, generate_rdf=False))
            elif node.rdf_error_flag == 2:
                cfg.output_queue.append(NormalMessage(None,
                                                      cfg.BRIGHT_PINK + "Warning: RDF file versions reached a maximum of 99, will append to file with version 00 (time for housekeeping?)." + cfg.COLOR_END,
                                                      display=True, generate_rdf=False))
            cfg.output_queue.append(
                NormalMessage(None, "Execution of TPF '" + cfg.GREEN + node.name + cfg.COLOR_END + "' completed.",
                              display=True, generate_rdf=False))
            # Mod5: end
